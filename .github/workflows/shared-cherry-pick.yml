# This shared workflow is used to cherry-pick PRs into another branch and generate a new PR.
# Once the PR is created it will
# - Assign the PR to the merger and original author of the PR.

name: Shared Cherry Pick
on:
  workflow_call:
    inputs:
      pr_number:
        description: 'Pull request number to cherry-pick'
        required: true
        type: string # Can't pass non-string into reusable workflow https://github.com/orgs/community/discussions/67182
      target_branch:
        description: 'Branch to cherry-pick into'
        required: true
        type: string
    outputs:
      status:
        description: 'Status of PR creation (success/failure)'
        value: ${{ jobs.aggregate-overall-status.outputs.status }}
      error_message:
        description: 'Error message if PR creation failed'
        value: ${{ jobs.aggregate-overall-status.outputs.error_message }}
      cherry_pick_pr_number:
        description: 'PR number created (if successful)'
        value: ${{ jobs.aggregate-overall-status.outputs.cherry_pick_pr_number }}

  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull request number to cherry-pick'
        required: true
        type: number
      target_branch:
        description: 'Branch to cherry-pick into'
        required: true
        type: string

env:
  GIT_COMMITTER_NAME: 'woocommercebot'
  GIT_COMMITTER_EMAIL: 'woocommercebot@users.noreply.github.com'
  GIT_AUTHOR_NAME: 'woocommercebot'
  GIT_AUTHOR_EMAIL: 'woocommercebot@users.noreply.github.com'

jobs:
  verify:
    name: Verify requirements
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    outputs:
      status: ${{ steps.aggregate-status.outputs.status }}
      error_message: ${{ steps.aggregate-status.outputs.error_message }}
      cherry_pick_branch: ${{ steps.aggregate-status.outputs.cherry_pick_branch }}
      merge_commit_sha: ${{ steps.check-pr.outputs.merge_commit_sha }}
    steps:
      - name: Validate PR and get merge commit
        id: check-pr
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea #v7.0.1
        with:
          script: |
            const prNumber = parseInt('${{ inputs.pr_number }}', 10);

            if (isNaN(prNumber)) {
              core.setOutput('error_message', 'PR number is not a valid integer');
              core.setFailed('PR number is not a valid integer');
              return;
            }

            try {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              if (!pr.merged) {
                core.setOutput('error_message', `Pull request #${prNumber} is not merged.`);
                core.setFailed(`Pull request #${prNumber} is not merged.`);
                return;
              }

              if (!pr.merge_commit_sha) {
                core.setOutput('error_message', `Pull request #${prNumber} does not have a merge commit SHA.`);
                core.setFailed(`Pull request #${prNumber} does not have a merge commit SHA.`);
                return;
              }

              core.setOutput('merge_commit_sha', pr.merge_commit_sha);
              core.info(`PR #${prNumber} is merged with commit SHA: ${pr.merge_commit_sha}`);

            } catch (error) {
              const errorMsg = error.status === 404
                ? `Pull request #${prNumber} does not exist.`
                : `Error fetching PR: ${error.message}`;

              core.setOutput('error_message', errorMsg);
              core.setFailed(errorMsg);
            }

      - name: Verify target branch and cherry-pick branch
        id: verify-branches
        if: steps.check-pr.outcome == 'success'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea #v7.0.1
        with:
          script: |
            const targetBranch = '${{ inputs.target_branch }}';
            const prNumber = '${{ inputs.pr_number }}';
            const cherryPickBranch = `cherry-pick-PR${prNumber}-to-${targetBranch}`;

            try {
              // 1. Verify target branch exists
              await github.rest.repos.getBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                branch: targetBranch
              });
              core.info(`Target branch '${targetBranch}' exists`);

              // 2. Check if cherry-pick branch exists
              let branchExists = false;
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: cherryPickBranch
                });
                branchExists = true;
                core.info(`Branch '${cherryPickBranch}' exists`);
              } catch (branchError) {
                if (branchError.status !== 404) throw branchError;
                core.info(`Branch '${cherryPickBranch}' does not exist (will be created)`);
              }

              // 3. Check if a PR already exists for this cherry-pick
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: `${context.repo.owner}:${cherryPickBranch}`,
                state: 'all'
              });

              if (prs.length === 0) {
                // No existing PR - proceed with cherry-pick
                core.info(`No existing PR found - ready to create cherry-pick`);
                core.setOutput('cherry_pick_branch', cherryPickBranch);
                return;
              }

              // 4. Handle existing PR scenarios
              const openPr = prs.find(pr => pr.state === 'open');
              const mergedPr = prs.find(pr => pr.merged_at);

              // Case 1: There's an open PR
              if (openPr) {
                core.info(`Found open PR #${openPr.number}`);
                core.setOutput('status', 'skipped');
                core.setOutput('error_message', `An open cherry-pick PR already exists: #${openPr.number}`);
                return;
              }

              // Case 2: A PR was already merged
              if (mergedPr) {
                core.info(`Found merged PR #${mergedPr.number}`);
                core.setOutput('status', 'skipped');
                core.setOutput('error_message', `A cherry-pick PR was already merged: #${mergedPr.number}`);
                return;
              }

              // Case 3: Only closed (not merged) PRs exist, we delete branch and create fresh PR
              if (branchExists) {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${cherryPickBranch}`
                  });
                core.info(`Found only closed PRs. Deleted branch '${cherryPickBranch}'.`);
              }
              
              core.setOutput('cherry_pick_branch', cherryPickBranch);

            } catch (error) {
              const errorMsg = error.status === 404
                ? `Target branch '${targetBranch}' does not exist`
                : `Error during verification: ${error.message}`;

              core.setOutput('error_message', errorMsg);
              core.setFailed(errorMsg);
            }

      - name: Set verification status
        id: aggregate-status
        if: always()
        run: |
          if [[ "${{ steps.verify-branches.outputs.status }}" == "skipped" ]]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "error_message=${{ steps.verify-branches.outputs.error_message }}" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.check-pr.outcome }}" == "failure" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=${{ steps.check-pr.outputs.error_message }}" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.verify-branches.outcome }}" == "failure" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=${{ steps.verify-branches.outputs.error_message }}" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "error_message=" >> $GITHUB_OUTPUT
            echo "cherry_pick_branch=${{ steps.verify-branches.outputs.cherry_pick_branch }}" >> $GITHUB_OUTPUT
          fi

  cherry-pick:
    name: Cherry Pick
    runs-on: ubuntu-latest
    needs: verify
    if: needs.verify.outputs.status == 'success'
    permissions:
      contents: write
      pull-requests: write
    outputs:
      status: ${{ steps.aggregate-status.outputs.status }}
      error_message: ${{ steps.aggregate-status.outputs.error_message }}
      cherry_pick_pr_number: ${{ steps.aggregate-status.outputs.cherry_pick_pr_number }}
    steps:
      - name: Checkout target branch
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 #v4.2.2
        with:
          ref: ${{ inputs.target_branch }}

      - name: Create and perform cherry-pick
        id: cherry-pick
        run: |
          set -e

          CHERRY_PICK_BRANCH="${{ needs.verify.outputs.cherry_pick_branch }}"
          MERGE_COMMIT_SHA="${{ needs.verify.outputs.merge_commit_sha }}"
          PR_NUMBER="${{ inputs.pr_number }}"
          TARGET_BRANCH="${{ inputs.target_branch }}"

          # Check if branch already exists
          if git ls-remote --heads origin "$CHERRY_PICK_BRANCH" | grep -q "$CHERRY_PICK_BRANCH"; then
            echo "Branch $CHERRY_PICK_BRANCH already exists remotely. Skipping cherry-pick."
            exit 0
          fi

          # Create cherry-pick branch
          git checkout -b "$CHERRY_PICK_BRANCH"
          git fetch origin "$MERGE_COMMIT_SHA"

          # Attempt cherry-pick with explicit conflict handling
          if git cherry-pick -m1 "$MERGE_COMMIT_SHA"; then
            # Success case
            echo "has_conflicts=false" >> $GITHUB_OUTPUT
            echo "Cherry-pick completed successfully"
          else
            # Capture conflicted files with their status codes and build JSON array using jq
            CONFLICT_JSON=$(git status --porcelain | grep -E "^(DD|AU|UD|UA|DU|AA|UU)" | jq -R -n -c '
              [inputs | {status: .[0:2], file: .[3:]}]
            ')

            if [[ "$CONFLICT_JSON" != "[]" ]]; then
              echo "has_conflicts=true" >> $GITHUB_OUTPUT
              echo "conflict_status=$CONFLICT_JSON" >> $GITHUB_OUTPUT

              echo "Cherry-pick had conflicts - details: $CONFLICT_JSON"

              # Add all files (both conflicted and resolved)
              git add .

              # Check if we have anything to commit
              if ! git diff --cached --quiet; then
                git commit -m "Cherry-pick $MERGE_COMMIT_SHA with unresolved conflicts from #$PR_NUMBER"
                echo "Conflicts committed successfully"
              else
                echo "error_message=Cherry-pick had conflicts but resulted in no changes to commit. Manual resolution required." >> $GITHUB_OUTPUT
                exit 1
              fi

            else
              # No conflicts detected, check for other failure reasons
              if git log --oneline -1 2>/dev/null | grep -q "$MERGE_COMMIT_SHA"; then
                # Commit is already applied
                echo "error_message=Cannot create cherry-pick PR: PR #$PR_NUMBER is already present in branch '$TARGET_BRANCH'." >> $GITHUB_OUTPUT
                exit 1
              else
                echo "error_message=Cherry-pick failed for unknown reasons. Please check the commit compatibility with target branch '$TARGET_BRANCH'." >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          fi

          # Validate we have commits to push
          if git rev-list --count "origin/$TARGET_BRANCH..HEAD" | grep -q "^0$"; then
            echo "error_message=Cherry-pick completed but created no new commits. PR #$PR_NUMBER appears to already exist in '$TARGET_BRANCH'." >> $GITHUB_OUTPUT
            exit 1
          fi

          # Push the branch
          git push origin "$CHERRY_PICK_BRANCH"

      - name: Create cherry-pick pull request
        id: create-pr
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea #v7.0.1
        env:
          CONFLICT_STATUS: ${{ steps.cherry-pick.outputs.conflict_status }}
        with:
          github-token: ${{ secrets.WC_BOT_PR_CREATE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ inputs.pr_number }}';
            const targetBranch = '${{ inputs.target_branch }}';
            const cherryPickBranch = '${{ needs.verify.outputs.cherry_pick_branch }}';
            const hasConflicts = '${{ steps.cherry-pick.outputs.has_conflicts }}' === 'true';

            try {
              // Get original PR details
              const { data: originalPr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              // Create PR body
              let prBody = `This PR is a cherry-pick of #${prNumber} to \`${targetBranch}\`.\n\n`;

              if (hasConflicts) {
                prBody += `> [!WARNING]\n`;
                prBody += `> This cherry-pick contained conflicts that have not been resolved\n`;
                prBody += `> 1. Review and resolve all conflicts\n`;
                prBody += `> 2. Remove the \`cherry pick has conflicts\` label (required to merge)\n`;

                // Parse JSON array of conflicts
                const conflicts = JSON.parse(process.env.CONFLICT_STATUS || '[]');
                // Map status codes to human-readable descriptions
                const conflictTypeMap = {
                  'DD': 'deleted by both',
                  'UA': 'added by cherry-pick, does not exist in target branch',
                  'UD': 'deleted by cherry-pick, modified in target branch',
                  'AU': 'modified by cherry-pick, added in target branch',
                  'DU': 'modified by cherry-pick, deleted in target branch',
                  'AA': 'added by both with different content',
                  'UU': 'modified by both'
                };
                prBody += `>\n`; // Empty blockquote line for spacing
                prBody += `> **Conflicted Files:**\n`;
                for (const { status, file } of conflicts) {
                  const conflictType = conflictTypeMap[status] || 'unknown conflict type';
                  prBody += `> - \`${file}\` (${conflictType})\n`;
                }
                prBody += `\n`;
              }

              prBody += `## Original PR Description\n\n${originalPr.body || '*No description provided*'}`;

              // Replace milestone selection and changelog sections.
              prBody = prBody.replace(/\[\s*(?:[xX])?\s*\]\s*(Automatically create a changelog.*)/g, '[ ] ~~$1~~');
              prBody = prBody.replace(/\[\s*(?:[xX])?\s*\]\s*(This Pull Request does not require a changelog.*)/g, '[ ] ~~$1~~');
              prBody = prBody.replace(/\[\s*(?:[xX])?\s*\]\s*(Automatically assign milestone.*\*\*.*next WooCommerce version.*\*\*.*)/g, '[ ] ~~$1~~');

              // Create new PR
              const { data: newPr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head: cherryPickBranch,
                base: targetBranch,
                title: `[Backport to ${targetBranch}] ${originalPr.title}`,
                body: prBody
              });
              
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: newPr.number,
                reviewers: [context.actor, originalPr.user.login]
              });

              // Add label if there are conflicts
              if (hasConflicts) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: newPr.number,
                    labels: ['cherry pick has conflicts']
                  });
                  core.info(`Added 'cherry pick has conflicts' label to PR #${newPr.number}`);
                } catch (error) {
                  core.warning(`Failed to add conflicts label: ${error.message}`);
                }
              }

              core.setOutput('pr_number', newPr.number.toString());
              core.setOutput('original_author', originalPr.user?.login || '');
              core.setOutput('original_merger', originalPr.merged_by?.login || '');

              core.info(`Created PR #${newPr.number}: ${newPr.html_url}`);

            } catch (error) {
              core.setOutput('error_message', `Failed to create PR: ${error.message}`);
              core.setFailed(`Failed to create PR: ${error.message}`);
            }

      - name: Assign PR
        if: steps.create-pr.outcome == 'success'
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea #v7.0.1
        with:
          github-token: ${{ secrets.WC_BOT_PR_CREATE_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = '${{ steps.create-pr.outputs.pr_number }}';
            const originalAuthor = '${{ steps.create-pr.outputs.original_author }}';
            const originalMerger = '${{ steps.create-pr.outputs.original_merger }}';
            const hasConflicts = '${{ steps.cherry-pick.outputs.has_conflicts }}' === 'true';

            // Assign PR to original author and merger
            const assignees = [originalAuthor, originalMerger].filter((user, index, arr) =>
              user && user.trim() !== '' && arr.indexOf(user) === index
            );

            if (assignees.length > 0) {
              try {
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  assignees: assignees
                });
                core.info(`Assigned PR to: ${assignees.join(', ')}`);
              } catch (error) {
                core.warning(`Failed to assign PR: ${error.message}`);
              }
            }

      - name: Set cherry-pick status
        id: aggregate-status
        if: always()
        run: |
          if [[ "${{ steps.cherry-pick.outcome }}" == "failure" ]]; then
            # Use the detailed error message from cherry-pick step
            error_msg="${{ steps.cherry-pick.outputs.error_message }}"
            if [[ -z "$error_msg" ]]; then
              error_msg="Cherry-pick operation failed unexpectedly"
            fi
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=$error_msg" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.create-pr.outcome }}" == "failure" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=${{ steps.create-pr.outputs.error_message }}" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "error_message=" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=${{ steps.create-pr.outputs.pr_number }}" >> $GITHUB_OUTPUT
          fi

  aggregate-overall-status:
    name: Aggregate final status
    runs-on: ubuntu-latest
    needs: [verify, cherry-pick]
    if: always()
    outputs:
      status: ${{ steps.set-outputs.outputs.status }}
      error_message: ${{ steps.set-outputs.outputs.error_message }}
      cherry_pick_pr_number: ${{ steps.set-outputs.outputs.cherry_pick_pr_number }}
    steps:
      - name: Set final outputs
        id: set-outputs
        run: |
          verify_status="${{ needs.verify.outputs.status }}"
          cherry_status="${{ needs.cherry-pick.outputs.status }}"

          if [[ "$verify_status" == "skipped" ]]; then
            echo "status=skipped" >> $GITHUB_OUTPUT
            echo "error_message=${{ needs.verify.outputs.error_message }}" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=" >> $GITHUB_OUTPUT
          elif [[ "$verify_status" != "success" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=${{ needs.verify.outputs.error_message }}" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=" >> $GITHUB_OUTPUT
          elif [[ "$cherry_status" != "success" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "error_message=${{ needs.cherry-pick.outputs.error_message }}" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "error_message=" >> $GITHUB_OUTPUT
            echo "cherry_pick_pr_number=${{ needs.cherry-pick.outputs.cherry_pick_pr_number }}" >> $GITHUB_OUTPUT
          fi